# 开发业务代码

本文档详细说明如何在新模块中开发业务代码，包括实体类、Mapper、Service、Controller 的完整开发流程。

我们继续以**商品管理模块（am-product）**为例。

## 1. 创建实体类（Entity）

实体类对应数据库表结构，使用 MyBatis Plus 注解。

### 1.1 商品实体类

创建 `com.thirty.product.model.entity.Product.java`：

```java
@Data
@TableName("product")
public class Product {
    
    @TableId(type = IdType.AUTO)
    private Integer id;
    
    private String name;
    
    private String description;
    
    private BigDecimal price;
    
    private Integer stock;
    
    private Integer categoryId;
    
    private String imageUrl;
    
    private Integer status;
    
    @TableLogic
    private Integer isDeleted;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
}
```

**注解说明：**
- `@TableName`: 指定表名
- `@TableId(type = IdType.AUTO)`: 主键自增
- `@TableLogic`: 逻辑删除字段
- `@TableField(fill = FieldFill.INSERT)`: 插入时自动填充
- `@TableField(fill = FieldFill.INSERT_UPDATE)`: 插入和更新时自动填充

### 1.2 命名规范

- 类名：大驼峰，与表名对应（如 `product` → `Product`）
- 字段名：小驼峰，与数据库字段对应（如 `category_id` → `categoryId`）
- 必须包含：`id`、`isDeleted`、`createTime`、`updateTime`

## 2. 创建 DTO 和 VO

### 2.1 DTO（数据传输对象）

DTO 用于接收前端请求参数，需要添加校验注解。

#### 添加商品 DTO

创建 `com.thirty.product.model.dto.AddProductDTO.java`：

```java
@Data
public class AddProductDTO {
    
    @NotBlank(message = "商品名称不能为空")
    @Size(max = 100, message = "商品名称长度不能超过100")
    private String name;
    
    @Size(max = 500, message = "商品描述长度不能超过500")
    private String description;
    
    @NotNull(message = "商品价格不能为空")
    @DecimalMin(value = "0.01", message = "商品价格必须大于0")
    @DecimalMax(value = "999999.99", message = "商品价格不能超过999999.99")
    private BigDecimal price;
    
    @NotNull(message = "库存数量不能为空")
    @Min(value = 0, message = "库存数量不能为负数")
    private Integer stock;
    
    private Integer categoryId;
    
    @Size(max = 500, message = "图片URL长度不能超过500")
    private String imageUrl;
}
```

**常用校验注解：**
- `@NotNull`: 不能为 null
- `@NotBlank`: 不能为空字符串
- `@Size`: 字符串长度限制
- `@Min` / `@Max`: 数值范围
- `@DecimalMin` / `@DecimalMax`: 小数范围
- `@Pattern`: 正则表达式
- `@Email`: 邮箱格式

#### 查询商品 DTO

创建 `com.thirty.product.model.dto.GetProductsDTO.java`：

```java
@Data
public class GetProductsDTO {
    private String name;           // 商品名称（模糊查询）
    private Integer categoryId;    // 分类ID
    private Integer status;        // 状态
    private BigDecimal minPrice;   // 最低价格
    private BigDecimal maxPrice;   // 最高价格
}
```

### 2.2 VO（视图对象）

VO 用于返回给前端的数据。

创建 `com.thirty.product.model.vo.ProductVO.java`：

```java
@Data
public class ProductVO {
    private Integer id;
    private String name;
    private String description;
    private BigDecimal price;
    private Integer stock;
    private Integer categoryId;
    private String categoryName;    // 关联查询的分类名称
    private String imageUrl;
    private Integer status;
    private String statusText;      // 状态文本（前端展示）
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}
```

**VO 设计原则：**
- 只包含前端需要的字段
- 可以包含关联查询的数据
- 可以包含计算字段（如状态文本）
- 不包含敏感信息（如密码）

## 3. 创建 Converter（对象转换）

使用 MapStruct 实现对象转换，避免手动赋值。

创建 `com.thirty.product.converter.ProductConverter.java`：

```java
@Mapper(componentModel = "spring")
public interface ProductConverter {
    
    /**
     * DTO 转 Entity
     */
    Product toEntity(AddProductDTO dto);
    
    /**
     * Entity 转 VO
     */
    @Mapping(target = "statusText", expression = "java(getStatusText(entity.getStatus()))")
    ProductVO toVO(Product entity);
    
    /**
     * 状态转文本
     */
    default String getStatusText(Integer status) {
        return status == 1 ? "上架" : "下架";
    }
}
```

**MapStruct 说明：**
- `@Mapper(componentModel = "spring")`: 生成 Spring Bean
- `@Mapping`: 自定义字段映射
- `expression`: 使用 Java 表达式
- `default`: 默认方法，可以编写转换逻辑

编译后会自动生成实现类，可以直接注入使用。

## 4. 创建 Mapper（数据访问层）

### 4.1 Mapper 接口

创建 `com.thirty.product.mapper.ProductMapper.java`：

```java
/**
 * 商品 Mapper
 * 注意：Service 层调用时会通过切面自动切换到 product 数据源
 */
public interface ProductMapper extends BaseMapper<Product> {
    
    /**
     * 分页查询商品列表（带关联查询）
     */
    IPage<ProductVO> getProducts(IPage<ProductVO> page, @Param("params") GetProductsDTO params);
}
```

**重要：**
- 必须继承 `BaseMapper<T>`
- 数据源通过 Service 层的切面自动切换
- 自定义方法需要在 XML 中实现

### 4.2 Mapper XML

创建 `backend/am-product/src/main/resources/mapper/ProductMapper.xml`：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.thirty.product.mapper.ProductMapper">
    
    <!-- 查询商品列表 -->
    <select id="getProducts" resultType="com.thirty.product.model.vo.ProductVO">
        SELECT 
            p.id,
            p.name,
            p.description,
            p.price,
            p.stock,
            p.category_id AS categoryId,
            c.name AS categoryName,
            p.image_url AS imageUrl,
            p.status,
            p.create_time AS createTime,
            p.update_time AS updateTime
        FROM product p
        LEFT JOIN product_category c ON p.category_id = c.id
        WHERE p.is_deleted = 0
        <if test="params.name != null and params.name != ''">
            AND p.name LIKE CONCAT('%', #{params.name}, '%')
        </if>
        <if test="params.categoryId != null">
            AND p.category_id = #{params.categoryId}
        </if>
        <if test="params.status != null">
            AND p.status = #{params.status}
        </if>
        <if test="params.minPrice != null">
            AND p.price &gt;= #{params.minPrice}
        </if>
        <if test="params.maxPrice != null">
            AND p.price &lt;= #{params.maxPrice}
        </if>
        ORDER BY p.create_time DESC
    </select>
    
</mapper>
```

**XML 编写规范：**
- `namespace` 必须与 Mapper 接口全限定名一致
- `resultType` 指定返回类型
- 使用 `<if>` 标签实现动态 SQL
- 使用 `&gt;` 和 `&lt;` 代替 `>` 和 `<`

## 5. 创建 Service 层

Service 层分为三层：Facade、Domain、Basic，各有明确职责。

### 5.1 Basic Service（基础服务层）

**职责：** 对单一表进行增删改查

Basic Service 继承 MyBatis Plus 的 `IService`，提供基础 CRUD 操作。

#### 接口

创建 `com.thirty.product.service.basic.ProductBasicService.java`：

```java
public interface ProductBasicService extends IService<Product> {
    // 继承了 save、update、delete、getById 等方法
    // 可以添加针对单表的自定义方法
}
```

#### 实现类

创建 `com.thirty.product.service.basic.impl.ProductBasicServiceImpl.java`：

```java
@Service
public class ProductBasicServiceImpl 
    extends ServiceImpl<ProductMapper, Product> 
    implements ProductBasicService {
    
    // 可以添加针对单表的自定义实现
}
```

**继承说明：**
- 继承 `ServiceImpl<Mapper, Entity>`
- 自动拥有 CRUD 方法：
  - `save(entity)`: 插入
  - `updateById(entity)`: 更新
  - `removeById(id)`: 删除（逻辑删除）
  - `getById(id)`: 查询
  - `list()`: 查询列表
  - `page()`: 分页查询

### 5.2 Domain Service（领域服务层）

**职责：**
- 对象转换（DTO/Entity/VO）
- 事务管理（@Transactional）
- 协调多表之间的操作

#### 接口

创建 `com.thirty.product.service.domain.ProductDomain.java`：

```java
public interface ProductDomain {
    
    /**
     * 创建商品（包含对象转换和多表操作）
     */
    Integer createProduct(AddProductDTO dto);
    
    /**
     * 获取商品详情（包含对象转换）
     */
    ProductVO getProductDetail(Integer id);
    
    /**
     * 分页查询商品列表
     */
    IPage<ProductVO> getProducts(PageQueryDTO<GetProductsDTO> request);
}
```

#### 实现类

创建 `com.thirty.product.service.domain.impl.ProductDomainImpl.java`：

```java
@Service
public class ProductDomainImpl implements ProductDomain {
    
    @Resource
    private ProductBasicService productBasicService;
    
    @Resource
    private ProductCategoryBasicService categoryBasicService;
    
    @Resource
    private ProductMapper productMapper;
    
    @Resource
    private ProductConverter productConverter;
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public Integer createProduct(AddProductDTO dto) {
        // 1. 对象转换
        Product product = productConverter.toEntity(dto);
        product.setStatus(1); // 设置默认值
        
        // 2. 保存商品主表
        productBasicService.save(product);
        
        // 3. 如果需要操作其他表（多表协调）
        if (dto.getCategoryId() != null) {
            // 更新分类的商品数量
            categoryBasicService.incrementProductCount(dto.getCategoryId());
        }
        
        return product.getId();
    }
    
    @Override
    public ProductVO getProductDetail(Integer id) {
        // 1. 查询数据
        Product product = productBasicService.getById(id);
        
        // 2. 对象转换
        return productConverter.toVO(product);
    }
    
    @Override
    public IPage<ProductVO> getProducts(PageQueryDTO<GetProductsDTO> request) {
        // 创建分页对象
        IPage<ProductVO> page = new Page<>(
            request.getPageNum(), 
            request.getPageSize()
        );
        
        // 查询数据
        return productMapper.getProducts(page, request.getData());
    }
}
```

**Domain 层特点：**
- 使用 `@Transactional` 管理事务
- 调用 Converter 进行对象转换
- 协调多个 Basic Service 操作多张表
- 不处理业务异常（由 Facade 层处理）

### 5.3 Facade Service（门面层）

**职责：**
- 异常处理和业务校验
- 数据级别的权限校验
- 协调多个小模块之间的操作

#### 接口

创建 `com.thirty.product.service.facade.ProductFacade.java`：

```java
public interface ProductFacade {
    
    /**
     * 添加商品
     */
    Integer addProduct(Integer userId, AddProductDTO dto);
    
    /**
     * 获取商品详情
     */
    ProductVO getProduct(Integer id);
    
    /**
     * 分页查询商品列表
     */
    IPage<ProductVO> getProducts(PageQueryDTO<GetProductsDTO> request);
    
    /**
     * 更新商品
     */
    void updateProduct(Integer userId, Integer id, AddProductDTO dto);
    
    /**
     * 删除商品
     */
    void deleteProduct(Integer userId, Integer id);
}
```

#### 实现类

创建 `com.thirty.product.service.facade.impl.ProductFacadeImpl.java`：

```java
@Service
public class ProductFacadeImpl implements ProductFacade {
    
    @Resource
    private ProductDomain productDomain;
    
    @Resource
    private ProductBasicService productBasicService;
    
    @Resource
    private UserBasicService userBasicService;  // 跨模块调用
    
    @Override
    public Integer addProduct(Integer userId, AddProductDTO dto) {
        // 1. 数据级权限校验
        User user = userBasicService.getById(userId);
        if (user == null) {
            throw new BusinessException(GlobalResultCode.USER_NOT_FOUND);
        }
        
        // 2. 业务校验
        if (dto.getPrice().compareTo(BigDecimal.ZERO) <= 0) {
            throw new BusinessException(ProductResultCode.INVALID_PRICE);
        }
        
        // 3. 调用 Domain 层
        return productDomain.createProduct(dto);
    }
    
    @Override
    public ProductVO getProduct(Integer id) {
        // 1. 参数校验
        if (id == null || id <= 0) {
            throw new BusinessException(GlobalResultCode.INVALID_PARAMETER);
        }
        
        // 2. 调用 Domain 层
        ProductVO product = productDomain.getProductDetail(id);
        
        // 3. 异常处理
        if (product == null) {
            throw new BusinessException(ProductResultCode.PRODUCT_NOT_FOUND);
        }
        
        return product;
    }
    
    @Override
    public IPage<ProductVO> getProducts(PageQueryDTO<GetProductsDTO> request) {
        // 直接调用 Domain 层
        return productDomain.getProducts(request);
    }
    
    @Override
    public void updateProduct(Integer userId, Integer id, AddProductDTO dto) {
        // 1. 检查商品是否存在
        Product product = productBasicService.getById(id);
        if (product == null) {
            throw new BusinessException(ProductResultCode.PRODUCT_NOT_FOUND);
        }
        
        // 2. 数据级权限校验（例如：只能修改自己创建的商品）
        if (!product.getCreatorId().equals(userId)) {
            throw new BusinessException(GlobalResultCode.PERMISSION_DENIED);
        }
        
        // 3. 业务逻辑
        product.setName(dto.getName());
        product.setPrice(dto.getPrice());
        product.setStock(dto.getStock());
        
        productBasicService.updateById(product);
    }
    
    @Override
    public void deleteProduct(Integer userId, Integer id) {
        // 1. 检查商品是否存在
        Product product = productBasicService.getById(id);
        if (product == null) {
            throw new BusinessException(ProductResultCode.PRODUCT_NOT_FOUND);
        }
        
        // 2. 数据级权限校验
        if (!product.getCreatorId().equals(userId)) {
            throw new BusinessException(GlobalResultCode.PERMISSION_DENIED);
        }
        
        // 3. 执行删除
        boolean success = productBasicService.removeById(id);
        if (!success) {
            throw new BusinessException(ProductResultCode.PRODUCT_DELETE_FAILED);
        }
    }
}
```

**Facade 层特点：**
- 处理所有业务异常
- 进行数据级权限校验
- 可以跨模块调用其他 Service
- 协调多个 Domain 层的操作
- 不直接使用 `@Transactional`（由 Domain 层管理）

### 5.4 三层职责总结

| 层级 | 职责 | 事务 | 异常处理 | 对象转换 |
|------|------|------|----------|----------|
| **Facade** | 异常处理、权限校验、模块协调 | ❌ | ✅ | ❌ |
| **Domain** | 对象转换、事务管理、多表协调 | ✅ | ❌ | ✅ |
| **Basic** | 单表 CRUD | ❌ | ❌ | ❌ |

**调用链：**
```
Controller → Facade → Domain → Basic → Mapper
```

## 6. 创建结果码枚举

创建 `com.thirty.product.enums.result.ProductResultCode.java`：

```java
@Getter
@AllArgsConstructor
public enum ProductResultCode implements IResult {
    
    // 成功码（统一使用 GlobalResultCode.SUCCESS.getCode()，即 200）
    PRODUCT_ADD_SUCCESS(GlobalResultCode.SUCCESS.getCode(), "添加成功"),
    PRODUCT_UPDATE_SUCCESS(GlobalResultCode.SUCCESS.getCode(), "更新成功"),
    PRODUCT_DELETE_SUCCESS(GlobalResultCode.SUCCESS.getCode(), "删除成功"),
    PRODUCT_GET_SUCCESS(GlobalResultCode.SUCCESS.getCode(), "获取成功"),
    PRODUCT_LIST_GET_SUCCESS(GlobalResultCode.SUCCESS.getCode(), "列表获取成功"),
    
    // 失败码（使用 6xxx 段，避免与其他模块冲突）
    PRODUCT_NOT_FOUND(6001, "商品不存在"),
    PRODUCT_NAME_EXISTS(6002, "商品名称已存在"),
    PRODUCT_STOCK_NOT_ENOUGH(6003, "商品库存不足"),
    PRODUCT_PRICE_INVALID(6004, "商品价格无效"),
    PRODUCT_DELETE_FAILED(6005, "商品删除失败"),
    ;
    
    private final Integer code;
    private final String message;
}
```

### 6.1 结果码规范

**1. 成功码**
- 统一使用 `GlobalResultCode.SUCCESS.getCode()`（值为 200）
- 消息简短明了：如"添加成功"、"获取成功"、"修改成功"、"删除成功"

**2. 失败码**
- 使用模块专属错误码段（千位数区分模块）
- 消息具体描述错误原因，便于定位问题

**3. 错误码段分配**

新模块应使用 **6xxx 及以上**的错误码段，已有模块的错误码段如下：

### 6.2 错误码段分配

新模块应使用 **6xxx 及以上**的错误码段，已有模块的错误码段如下：

| 错误码段 | 模块 | 说明 |
|---------|------|------|
| 200 | Global | 成功（SUCCESS） |
| 400-499 | Global | 通用客户端错误 |
| 500-599 | Global | 通用服务端错误 |
| 1xxx | Auth | 认证相关（登录、注册、Token） |
| 2xxx | User | 用户管理 |
| 3xxx | System | 系统模块（文件上传、配置） |
| 4xxx | Role | 角色管理 |
| 5xxx | Permission | 权限管理 |
| 6xxx+ | - | 预留给新模块 |

**新模块错误码分配建议：**
- **6xxx**: 第一个新模块（如商品模块）
- **7xxx**: 第二个新模块（如订单模块）
- **8xxx**: 第三个新模块（如库存模块）
- 以此类推...

**示例：**
```java
// 商品模块使用 6xxx
PRODUCT_NOT_FOUND(6001, "商品不存在"),
PRODUCT_NAME_EXISTS(6002, "商品名称已存在"),

// 订单模块使用 7xxx
ORDER_NOT_FOUND(7001, "订单不存在"),
ORDER_CANNOT_CANCEL(7002, "订单不能取消"),
```

**详细的已有结果码列表请参考：[附录-结果码参考.md](附录-结果码参考.md)**

## 7. 创建 Controller（控制层）

创建 `com.thirty.product.controller.ProductController.java`：

```java
@RestController
@RequestMapping("/product")
@OperateModule("商品管理")
@Tag(name = "商品管理", description = "商品相关接口")
public class ProductController {
    
    @Resource
    private ProductFacade productFacade;
    
    @Resource
    private JwtUtil jwtUtil;
    
    /**
     * 添加商品
     */
    @PostMapping("/add")
    @PreAuthorize("hasAuthority('product:add')")
    @OperateLog(type = OperationType.INSERT, description = "添加商品")
    @Operation(summary = "添加商品")
    public ResultDTO<Integer> addProduct(
            @RequestHeader("Authorization") String authHeader,
            @RequestBody @Valid AddProductDTO dto) {
        Integer userId = jwtUtil.getUserIdFromAuthHeader(authHeader);
        Integer productId = productFacade.addProduct(userId, dto);
        return ResultDTO.of(ProductResultCode.PRODUCT_ADD_SUCCESS, productId);
    }
    
    /**
     * 获取商品详情（简单查询用 GET）
     */
    @GetMapping("/get")
    @PreAuthorize("hasAuthority('product:view')")
    @OperateLog(type = OperationType.SELECT, description = "获取商品详情")
    @Operation(summary = "获取商品详情")
    public ResultDTO<ProductVO> getProduct(@RequestParam Integer id) {
        ProductVO product = productFacade.getProduct(id);
        return ResultDTO.of(ProductResultCode.PRODUCT_GET_SUCCESS, product);
    }
    
    /**
     * 分页查询商品列表（复杂查询用 POST + RequestBody）
     */
    @PostMapping("/list")
    @PreAuthorize("hasAuthority('product:list')")
    @OperateLog(type = OperationType.SELECT, description = "查询商品列表")
    @Operation(summary = "查询商品列表")
    public ResultDTO<IPage<ProductVO>> getProducts(
            @RequestBody @Valid PageQueryDTO<GetProductsDTO> request) {
        IPage<ProductVO> page = productFacade.getProducts(request);
        return ResultDTO.of(ProductResultCode.PRODUCT_LIST_GET_SUCCESS, page);
    }
    
    /**
     * 更新商品
     */
    @PostMapping("/update")
    @PreAuthorize("hasAuthority('product:edit')")
    @OperateLog(type = OperationType.UPDATE, description = "更新商品")
    @Operation(summary = "更新商品")
    public ResultDTO<Void> updateProduct(
            @RequestHeader("Authorization") String authHeader,
            @RequestBody @Valid UpdateProductDTO dto) {
        Integer userId = jwtUtil.getUserIdFromAuthHeader(authHeader);
        productFacade.updateProduct(userId, dto.getId(), dto);
        return ResultDTO.of(ProductResultCode.PRODUCT_UPDATE_SUCCESS);
    }
    
    /**
     * 删除商品
     */
    @PostMapping("/delete")
    @PreAuthorize("hasAuthority('product:delete')")
    @OperateLog(type = OperationType.DELETE, description = "删除商品")
    @Operation(summary = "删除商品")
    public ResultDTO<Void> deleteProduct(
            @RequestHeader("Authorization") String authHeader,
            @RequestBody List<Integer> ids) {
        Integer userId = jwtUtil.getUserIdFromAuthHeader(authHeader);
        productFacade.deleteProducts(userId, ids);
        return ResultDTO.of(ProductResultCode.PRODUCT_DELETE_SUCCESS);
    }
}
```

**Controller 开发规范：**

1. **类注解：**
   - `@RestController`: REST 控制器
   - `@RequestMapping`: 统一路径前缀
   - `@OperateModule`: 操作模块名（用于日志）
   - `@Tag`: API 文档分组

2. **方法注解：**
   - `@GetMapping`: 简单查询（使用 @RequestParam 或路径参数）
   - `@PostMapping`: 复杂操作（包括需要 @RequestBody 的查询、增删改操作）
   - `@PreAuthorize`: 权限控制
   - `@OperateLog`: 操作日志
   - `@Operation`: API 文档说明

3. **参数注解：**
   - `@RequestBody`: 接收 JSON 请求体（复杂参数）
   - `@RequestParam`: 接收查询参数（简单参数）
   - `@RequestHeader`: 接收请求头（如 Authorization）
   - `@Valid`: 参数校验

4. **HTTP 方法使用规范：**
   - **GET**: 简单查询，参数通过 URL 传递
     - 示例：`/product/get?id=1`
   - **POST**: 复杂操作，参数通过 RequestBody 传递
     - 查询：需要复杂查询条件时（如分页、多条件筛选）
     - 增删改：所有增删改操作
     - 示例：`/product/list` (POST + RequestBody)
     - 示例：`/product/add` (POST + RequestBody)
     - 示例：`/product/update` (POST + RequestBody)
     - 示例：`/product/delete` (POST + RequestBody)

5. **返回值：**
   - 统一使用 `ResultDTO<T>`
   - 使用结果码枚举

## 8. 测试接口

### 8.1 启动项目

```bash
# 在 backend 目录下
mvnw spring-boot:run -pl am-core
```

### 8.2 访问 API 文档

打开浏览器访问：http://localhost:8080/doc.html

在文档中可以看到新增的商品管理接口，可以直接测试。

### 8.3 测试添加商品

使用 Postman 或 API 文档测试：

**请求：**
```http
POST http://localhost:8080/product/add
Content-Type: application/json
Authorization: Bearer {your_token}

{
  "name": "测试商品",
  "description": "这是一个测试商品",
  "price": 99.99,
  "stock": 100,
  "categoryId": 1
}
```

**响应：**
```json
{
  "code": 20001,
  "message": "商品添加成功",
  "data": 1
}
```

### 8.4 测试查询商品列表

**请求：**
```http
POST http://localhost:8080/product/list
Content-Type: application/json
Authorization: Bearer {your_token}

{
  "pageNum": 1,
  "pageSize": 10,
  "data": {
    "name": "测试",
    "status": 1
  }
}
```

## 9. 开发检查清单

完成业务代码开发后，请检查：

- [ ] 创建了 Entity 实体类
- [ ] 创建了 DTO 和 VO
- [ ] 创建了 Converter 转换器
- [ ] 创建了 Mapper 接口和 XML
- [ ] 创建了 Basic Service
- [ ] 创建了 Facade Service
- [ ] 创建了结果码枚举
- [ ] 创建了 Controller
- [ ] 添加了参数校验注解
- [ ] 添加了权限控制注解
- [ ] 添加了操作日志注解
- [ ] 添加了 API 文档注解
- [ ] 添加了事务注解
- [ ] 测试了所有接口

## 10. 下一步

业务代码开发完成后，接下来需要：

1. 配置权限控制（参考《4.权限控制集成.md》）
2. 使用现有模块功能（参考《5.使用现有模块.md》）
3. 开发前端页面（参考前端开发文档）

---

**提示：** 建议按照本文档的顺序逐步开发，每完成一层就测试一次，确保功能正常后再继续下一层。
