# 使用现有模块

本文档说明如何在新模块中使用 Auth Matrix 现有模块提供的功能。

**核心内容：** Facade 层的数据级权限校验。

## 1. 数据级权限校验（核心）

### 1.1 权限控制的两个层次

Auth Matrix 实现了两层权限控制：

**接口级权限（Controller 层）**

通过 `@PreAuthorize` 注解控制用户能否访问某个接口。

```java
@PostMapping("/delete")
@PreAuthorize("hasAuthority('user:delete')")
public ResultDTO<Void> deleteUser(@RequestBody List<Integer> userIds) {
    // 有 user:delete 权限的用户才能访问
}
```

**数据级权限（Facade 层）**

在 Facade 层校验用户能否操作某条具体数据。

```java
@Override
public void deleteUsers(Integer operatorUserId, List<Integer> userIds) {
    // 校验：只能删除权限范围内的用户
    if (!roleValidationBuilderFactory.create(operatorUserId)
            .forRoleTypes(RolesType.CHILD_AND_GLOBAL.toRoleTypes())
            .validateUsers(userIds)
    ) {
        throw new BusinessException(UserResultCode.ROLE_NOT_AUTHORIZED_DELETE);
    }
    
    userOperationDomain.deleteUsers(userIds);
}
```

**为什么需要数据级权限？**

假设有以下场景：
- 用户 A 是"销售部经理"，用户 B 是"技术部经理"
- 两者都有 `user:edit` 权限（接口级权限相同）
- 但 A 只能编辑销售部用户，B 只能编辑技术部用户（数据级权限不同）

接口级权限无法实现这种细粒度控制，必须在 Facade 层进行数据级权限校验。


### 1.2 角色层级关系

Auth Matrix 的角色是树形结构：

```
超级管理员（ID: 1）
├── 销售总监（ID: 10）
│   ├── 销售经理（ID: 11）
│   └── 销售专员（ID: 12）
└── 技术总监（ID: 20）
    ├── 技术经理（ID: 21）
    └── 开发工程师（ID: 22）
```

**角色权限规则：**
- 上级角色可以管理下级角色的用户
- 同级角色之间不能互相管理
- 全局角色可以被所有人管理

**角色类型：**

| 类型 | 说明 |
|------|------|
| `RoleType.SELF` | 当前用户自己的角色 |
| `RoleType.CHILD` | 当前用户角色的所有子角色 |
| `RoleType.GLOBAL` | 全局角色 |
| `RoleType.ALL` | 所有角色 |

**常用组合：**

| 组合 | 包含的角色类型 | 使用场景 |
|------|---------------|----------|
| `RolesType.CHILD_AND_GLOBAL` | 子角色 + 全局角色 | 添加/修改用户时，可以分配的角色 |
| `RolesType.CHILD_AND_SELF` | 子角色 + 自己的角色 | 添加角色时，可以选择的父角色 |

### 1.3 核心工具类

#### RoleValidationBuilderFactory（角色校验）

用于校验角色层级关系。

```java
@Resource
private RoleValidationBuilderFactory roleValidationBuilderFactory;

// 校验单个角色
boolean isValid = roleValidationBuilderFactory.create(userId)
    .forRoleType(RoleType.CHILD)
    .validateRole(targetRoleId);

// 校验多个角色
boolean isValid = roleValidationBuilderFactory.create(userId)
    .forRoleTypes(RolesType.CHILD_AND_GLOBAL.toRoleTypes())
    .validateRoles(targetRoleIds);

// 校验用户（通过用户的角色）
boolean isValid = roleValidationBuilderFactory.create(userId)
    .forRoleType(RoleType.CHILD)
    .validateUser(targetUserId);

// 校验多个用户
boolean isValid = roleValidationBuilderFactory.create(userId)
    .forRoleTypes(RolesType.CHILD_AND_GLOBAL.toRoleTypes())
    .validateUsers(targetUserIds);
```

#### RolesBuilderFactory（获取权限范围）

用于获取用户有权限的角色ID列表，用于查询时过滤数据。

```java
@Resource
private RolesBuilderFactory rolesBuilderFactory;

// 获取用户有权限的角色ID列表
List<Integer> permittedRoleIds = rolesBuilderFactory.create(userId)
    .forRoleTypes(RolesType.CHILD_AND_GLOBAL.toRoleTypes())
    .buildIds();
```

#### PermissionBkValidationDomain（权限校验）

用于校验用户是否拥有某些权限。

```java
@Resource
private PermissionBkValidationDomain permissionBkValidationDomain;

// 校验用户是否拥有某个权限
boolean hasPermission = permissionBkValidationDomain.validateUserHavePermission(
    userId, 
    permissionId
);

// 校验用户是否拥有多个权限
boolean hasPermissions = permissionBkValidationDomain.validateUserHavePermissions(
    userId, 
    permissionIds
);
```

### 1.4 使用示例

#### 示例 1：修改数据时校验权限

修改用户时，需要进行双重校验：

```java
@Override
public void modifyUser(Integer operatorUserId, ModifyUserDTO modifyUserDTO) {
    // 校验1：要修改的用户必须在权限范围内
    if (!roleValidationBuilderFactory.create(operatorUserId)
            .forRoleTypes(RolesType.CHILD_AND_GLOBAL.toRoleTypes())
            .validateUser(modifyUserDTO.getId()))
    {
        throw new BusinessException(UserResultCode.USER_NOT_AUTHORIZED_MODIFY);
    }
    
    // 校验2：要分配的角色必须在权限范围内
    if (!roleValidationBuilderFactory.create(operatorUserId)
            .forRoleTypes(RolesType.CHILD_AND_GLOBAL.toRoleTypes())
            .validateRoles(modifyUserDTO.getRoleIds()))
    {
        throw new BusinessException(UserResultCode.ROLE_NOT_AUTHORIZED_MODIFY);
    }
    
    userOperationDomain.modifyUser(modifyUserDTO);
}
```

#### 示例 2：查询列表时过滤数据

查询用户列表时，只返回权限范围内的用户：

**Facade 层：**

```java
@Override
public IPage<UserVO> getUsers(Integer currentUserId, PageQueryDTO<GetUsersDTO> pageQueryDTO) {
    // 获取当前用户有权限的角色ID列表
    List<Integer> permittedRoleIds = rolesBuilderFactory.create(currentUserId)
            .forRoleTypes(RolesType.CHILD_AND_GLOBAL.toRoleTypes())
            .buildIds();
    
    // 查询用户列表（只返回这些角色的用户）
    return userQueryDomain.getUsers(pageQueryDTO, permittedRoleIds, settingApi.hasPermissionDisplay());
}
```

**Mapper XML：**

```xml
<select id="getUsers" resultType="com.thirty.user.model.vo.UserVO">
    SELECT u.id, u.username, r.name AS roleName
    FROM user u
    LEFT JOIN user_role ur ON u.id = ur.user_id
    LEFT JOIN role r ON ur.role_id = r.id
    WHERE u.is_deleted = 0
    
    <!-- 权限过滤 -->
    <if test="permittedRoleIds != null and permittedRoleIds.size() > 0">
        AND r.id IN
        <foreach collection="permittedRoleIds" item="roleId" open="(" separator="," close=")">
            #{roleId}
        </foreach>
    </if>
    
    ORDER BY u.create_time DESC
</select>
```

### 1.5 在新模块中实现权限校验

以**商品管理模块**为例，演示如何实现数据级权限校验。

#### 步骤 1：设计数据表

在商品表中添加创建者相关字段：

```sql
CREATE TABLE product (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    
    -- 创建者信息（用于权限控制）
    creator_id INT NOT NULL COMMENT '创建者用户ID',
    creator_role_id INT NOT NULL COMMENT '创建者角色ID',
    
    is_deleted TINYINT NOT NULL DEFAULT 0,
    create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_creator_role (creator_role_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 步骤 2：Facade 层实现

```java
@Service
public class ProductFacadeImpl implements ProductFacade {
    
    @Resource
    private ProductService productService;
    
    @Resource
    private ProductDomain productDomain;
    
    @Resource
    private RoleValidationBuilderFactory roleValidationBuilderFactory;
    
    @Resource
    private RolesBuilderFactory rolesBuilderFactory;
    
    @Resource
    private RoleQueryDomain roleQueryDomain;
    
    /**
     * 添加商品
     */
    @Override
    public Integer addProduct(Integer userId, AddProductDTO dto) {
        Product product = productConverter.toEntity(dto);
        
        // 记录创建者信息
        product.setCreatorId(userId);
        List<Integer> roleIds = roleQueryDomain.getRoleIds(userId);
        product.setCreatorRoleId(roleIds.get(0));
        
        productService.save(product);
        return product.getId();
    }
    
    /**
     * 修改商品
     */
    @Override
    public void updateProduct(Integer userId, Integer id, UpdateProductDTO dto) {
        Product product = productService.getById(id);
        if (product == null) {
            throw new BusinessException(ProductResultCode.PRODUCT_NOT_FOUND);
        }
        
        // 数据级权限校验
        if (!canOperateProduct(userId, product)) {
            throw new BusinessException(GlobalResultCode.PERMISSION_DENIED);
        }
        
        product.setName(dto.getName());
        product.setPrice(dto.getPrice());
        productService.updateById(product);
    }
    
    /**
     * 查询商品列表（带权限过滤）
     */
    @Override
    public IPage<ProductVO> getProducts(Integer userId, PageQueryDTO<GetProductsDTO> request) {
        // 获取权限范围
        List<Integer> permittedRoleIds = rolesBuilderFactory.create(userId)
                .forRoleTypes(RolesType.CHILD_AND_GLOBAL.toRoleTypes())
                .buildIds();
        
        // 查询时过滤
        return productDomain.getProducts(request, permittedRoleIds);
    }
    
    /**
     * 判断用户是否可以操作商品
     */
    private boolean canOperateProduct(Integer userId, Product product) {
        // 创建者本人可以操作
        if (product.getCreatorId().equals(userId)) {
            return true;
        }
        
        // 上级可以操作下级创建的商品
        return roleValidationBuilderFactory.create(userId)
                .forRoleTypes(RolesType.CHILD_AND_GLOBAL.toRoleTypes())
                .validateRole(product.getCreatorRoleId());
    }
}
```

#### 步骤 3：Mapper XML 实现

```xml
<select id="getProducts" resultType="com.thirty.product.model.vo.ProductVO">
    SELECT p.id, p.name, p.price
    FROM product p
    WHERE p.is_deleted = 0
    
    <!-- 权限过滤 -->
    <if test="permittedRoleIds != null and permittedRoleIds.size() > 0">
        AND p.creator_role_id IN
        <foreach collection="permittedRoleIds" item="roleId" open="(" separator="," close=")">
            #{roleId}
        </foreach>
    </if>
    
    ORDER BY p.create_time DESC
</select>
```

### 1.6 权限校验最佳实践

**原则 1：在 Facade 层进行权限校验**

权限校验属于业务逻辑，应该在 Facade 层进行，而不是在 Controller 层。

**原则 2：先校验权限，再执行业务逻辑**

避免在权限校验失败前执行了不必要的业务逻辑或数据修改。

**原则 3：查询列表时在 SQL 中过滤**

使用权限角色ID列表在 SQL 中过滤数据，而不是在代码中过滤，这样性能更好且分页准确。

**原则 4：记录数据归属信息**

在数据表中记录 `creator_id` 和 `creator_role_id`，便于权限校验和数据追溯。


## 2. 使用 Common 模块

Common 模块提供了通用功能。

### 2.1 统一返回结果

```java
// 使用结果码枚举
return ResultDTO.of(ProductResultCode.PRODUCT_ADD_SUCCESS);
return ResultDTO.of(ProductResultCode.PRODUCT_ADD_SUCCESS, productId);
```

### 2.2 分页查询

```java
@PostMapping("/list")
public ResultDTO<IPage<ProductVO>> getProducts(
        @RequestBody PageQueryDTO<GetProductsDTO> request) {
    IPage<ProductVO> page = new Page<>(request.getPageNum(), request.getPageSize());
    return productMapper.getProducts(page, request.getData());
}
```

### 2.3 JWT 工具

```java
@Resource
private JwtUtil jwtUtil;

// 从 Authorization 头获取用户ID
Integer userId = jwtUtil.getUserIdFromAuthHeader(authHeader);
```

### 2.4 操作日志注解

```java
@RestController
@RequestMapping("/product")
@OperateModule("商品管理")
public class ProductController {
    
    @PostMapping("/add")
    @OperateLog(type = OperationType.INSERT, description = "添加商品")
    public ResultDTO<Void> addProduct() {
        // 自动记录操作日志
    }
}
```

### 2.5 限流注解

```java
@PostMapping("/add")
@RateLimiter(count = 10, time = 60)  // 60秒内最多10次
public ResultDTO<Void> addProduct() {
    // ...
}
```

### 2.6 异常处理

```java
// 抛出业务异常
if (product == null) {
    throw new BusinessException(ProductResultCode.PRODUCT_NOT_FOUND);
}

// 权限异常
if (!hasPermission) {
    throw new BusinessException(GlobalResultCode.PERMISSION_DENIED);
}
```

## 3. 使用 User 模块

### 3.1 获取用户信息

```java
@Resource
private UserQueryDomain userQueryDomain;

// 获取用户详细信息
UserVO user = userQueryDomain.getUser(userId);
```

### 3.2 获取用户角色

```java
@Resource
private RoleQueryDomain roleQueryDomain;

// 获取用户的角色ID列表
List<Integer> roleIds = roleQueryDomain.getRoleIds(userId);
```

### 3.3 权限查询

```java
@Resource
private PermissionBkQueryDomain permissionBkQueryDomain;

// 获取角色的权限ID列表
List<Integer> permissionIds = permissionBkQueryDomain.getPermissionId(roleId);

// 获取权限码列表
List<String> permissionCodes = permissionBkQueryDomain.getPermissionCode(roleIds);
```

## 4. 使用 System 模块

### 4.1 文件上传

```java
@Resource
private FileService fileService;

// 上传文件到阿里云 OSS
String fileUrl = fileService.uploadFile(file);
```

### 4.2 系统配置

```java
@Resource
private SettingApi settingApi;

// 获取系统配置
String value = settingApi.getSetting("config_key");

// 判断是否显示权限标识
boolean hasPermissionDisplay = settingApi.hasPermissionDisplay();
```

## 5. 跨模块调用注意事项

### 5.1 数据源自动切换

跨模块调用时，数据源会自动切换：

```java
@Service
public class ProductFacadeImpl implements ProductFacade {
    
    @Resource
    private ProductQueryDomain productQueryDomain;  // product 数据源
    
    @Resource
    private UserQueryDomain userQueryDomain;  // user 数据源
    
    public ProductDetailVO getProductDetail(Integer productId) {
        // 查询商品（自动切换到 product 数据源）
        ProductVO product = productQueryDomain.getProduct(productId);
        
        // 查询用户（自动切换到 user 数据源）
        UserVO creator = userQueryDomain.getUser(product.getCreatorId());
        
        // 组合数据
        ProductDetailVO vo = new ProductDetailVO();
        vo.setCreatorName(creator.getUsername());
        return vo;
    }
}
```

### 5.2 避免跨数据源事务

```java
// ❌ 错误：跨数据源事务
@Transactional
public void someMethod() {
    productDomain.saveProduct(product);  // product 数据源
    userDomain.updateUser(user);         // user 数据源
}

// ✅ 正确：分别使用事务
@Transactional(rollbackFor = Exception.class)
public void saveProduct(Product product) {
    productDomain.saveProduct(product);
}

@Transactional(rollbackFor = Exception.class)
public void updateUser(User user) {
    userDomain.updateUser(user);
}
```

## 6. 开发检查清单

在新模块中实现数据级权限校验时，请检查：

- [ ] 在数据表中添加了 `creator_id` 和 `creator_role_id` 字段
- [ ] 添加操作时记录了创建者信息
- [ ] 修改操作前校验了数据权限
- [ ] 删除操作前校验了数据权限
- [ ] 查询列表时使用权限角色ID列表过滤
- [ ] 批量操作时逐个校验了权限
- [ ] 使用 `RoleValidationBuilderFactory` 进行角色校验
- [ ] 使用 `RolesBuilderFactory` 获取权限范围
- [ ] 权限校验在 Facade 层进行
- [ ] 权限校验失败时抛出明确的业务异常
- [ ] 在 SQL 中进行权限过滤
- [ ] 避免了跨数据源事务

## 7. 总结

### 7.1 权限控制的三个层次

| 层次 | 位置 | 作用 | 实现方式 |
|------|------|------|----------|
| **接口级** | Controller | 控制能否访问接口 | `@PreAuthorize("hasAuthority('product:add')")` |
| **数据级** | Facade | 控制能否操作具体数据 | `roleValidationBuilderFactory.create(userId).validateUser(targetUserId)` |
| **字段级** | VO | 控制能否看到某些字段 | 根据权限决定是否返回敏感字段 |

### 7.2 核心工具类

| 工具类 | 用途 | 常用方法 |
|--------|------|----------|
| `RoleValidationBuilderFactory` | 校验角色层级关系 | `validateRole()`, `validateRoles()`, `validateUser()`, `validateUsers()` |
| `RolesBuilderFactory` | 获取权限范围 | `buildIds()`, `build()`, `buildTree()` |
| `PermissionBkValidationDomain` | 校验权限数据 | `validateUserHavePermission()`, `validateUserHavePermissions()` |
| `RoleQueryDomain` | 查询角色信息 | `getRoleIds()` |
| `PermissionBkQueryDomain` | 查询权限信息 | `getPermissionId()`, `getPermissionCode()` |
| `UserQueryDomain` | 查询用户信息 | `getUser()` |
| `JwtUtil` | JWT 工具 | `getUserIdFromAuthHeader()` |
| `SettingApi` | 系统配置 | `getSetting()`, `hasPermissionDisplay()` |
| `FileService` | 文件服务 | `uploadFile()` |

### 7.3 数据级权限校验要点

1. **在 Facade 层进行权限校验** - 这是业务逻辑的入口
2. **使用 Builder 模式进行校验** - 链式调用，清晰易读
3. **记录数据归属** - 在数据表中记录 `creator_id` 和 `creator_role_id`
4. **查询时过滤** - 在 SQL 中使用权限角色ID列表过滤数据
5. **明确的异常提示** - 权限不足时抛出清晰的业务异常

---

**提示：** 数据级权限校验是 Auth Matrix 权限体系的核心，务必在每个 Facade 方法中进行严格校验，确保用户只能操作自己权限范围内的数据。
