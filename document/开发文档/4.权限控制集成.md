# 权限控制集成

本文档说明如何将新开发的功能模块集成到 Auth Matrix 的权限管理体系中。

## 1. 权限体系概述

Auth Matrix 实现了完整的 RBAC1.0 权限模型，包含：

- **后端权限（permission_bk）**: 控制接口访问
- **角色（role）**: 权限的集合
- **用户角色（user_role）**: 用户与角色的关联

### 1.1 权限类型

**后端权限类型（type 字段）：**
- `1`: 目录（一级菜单，如：用户管理、权限管理）
- `2`: 菜单（二级菜单，如：用户列表、角色列表）
- `3`: 页面（独立页面，如：个人中心、403）
- `4`: 按钮/操作（具体操作，如：添加用户、编辑用户）

### 1.2 权限码规范

权限码格式：`模块:操作`

示例：
- `product:list` - 查看商品列表
- `product:add` - 添加商品
- `product:edit` - 编辑商品
- `product:delete` - 删除商品
- `product:view` - 查看商品详情

## 2. 添加后端权限

### 2.1 在数据库中添加权限

连接到 `am_user` 数据库，执行以下 SQL：

```sql
USE am_user;

-- 1. 添加商品管理目录（type=1）
INSERT INTO permission_bk (name, path, component, type, permission_code, parent_id, `order`, icon, is_valid, is_delete) 
VALUES ('商品管理', '', '', 1, '', 0, 5, 'Goods', 1, 0);

-- 获取刚插入的目录ID
SET @dir_id = LAST_INSERT_ID();

-- 2. 添加商品列表菜单（type=2）
INSERT INTO permission_bk (name, path, component, type, permission_code, parent_id, `order`, icon, is_valid, is_delete) 
VALUES ('商品列表', '/product/list', '/product/list/Index', 2, '', @dir_id, 1, 'List', 1, 0);

-- 获取菜单ID
SET @menu_id = LAST_INSERT_ID();

-- 3. 添加按钮权限（type=4）
INSERT INTO permission_bk (name, path, component, type, permission_code, parent_id, `order`, icon, is_valid, is_delete) 
VALUES 
('查看商品', '', '', 4, 'product:view', @menu_id, 1, '', 1, 0),
('添加商品', '', '', 4, 'product:add', @menu_id, 2, '', 1, 0),
('编辑商品', '', '', 4, 'product:edit', @menu_id, 3, '', 1, 0),
('删除商品', '', '', 4, 'product:delete', @menu_id, 4, '', 1, 0);
```

**字段说明：**
- `name`: 权限名称（中文）
- `path`: 路由路径（目录和按钮为空）
- `component`: 前端组件路径（目录和按钮为空）
- `type`: 权限类型（1-目录，2-菜单，3-页面，4-按钮）
- `permission_code`: 权限码（目录和菜单为空，按钮必填）
- `parent_id`: 父权限ID（层级关系）
- `order`: 排序
- `icon`: 图标（目录和菜单有，按钮为空）
- `is_valid`: 是否启用（1-启用，0-禁用）
- `is_delete`: 是否删除（0-未删除，1-已删除）

### 2.2 查看权限树

```sql
-- 查看商品管理的权限树
SELECT 
    p1.id AS dir_id,
    p1.name AS dir_name,
    p1.type AS dir_type,
    p2.id AS menu_id,
    p2.name AS menu_name,
    p2.type AS menu_type,
    p3.id AS button_id,
    p3.name AS button_name,
    p3.permission_code AS button_code,
    p3.type AS button_type
FROM permission_bk p1
LEFT JOIN permission_bk p2 ON p2.parent_id = p1.id AND p2.type = 2
LEFT JOIN permission_bk p3 ON p3.parent_id = p2.id AND p3.type = 4
WHERE p1.name = '商品管理' AND p1.type = 1
ORDER BY p1.`order`, p2.`order`, p3.`order`;
```

## 3. 添加前端菜单

前端菜单配置请参考前端开发文档。

后端只需要配置好权限码，前端会根据权限码控制页面和按钮的显示。

## 4. 分配权限给角色

### 4.1 超级管理员权限

**超级管理员默认拥有全部权限，无需手动分配。**

系统会自动判断超级管理员身份，赋予所有权限。添加新权限后，超级管理员可以立即使用。

### 4.2 给其他角色分配权限

**通过前端操作分配权限：**

1. 使用超级管理员账号登录系统
2. 进入「权限管理」→「角色管理」
3. 选择需要分配权限的角色
4. 点击「分配权限」按钮
5. 在权限树中勾选需要分配的权限
6. 保存配置

**示例场景：**
- **商品管理员**：分配 `product:view`、`product:add`、`product:edit` 权限
- **商品查看员**：只分配 `product:view` 权限
- **商品审核员**：分配 `product:view`、`product:edit` 权限

## 5. 在代码中使用权限

### 5.1 Controller 方法级权限

```java
@RestController
@RequestMapping("/product")
public class ProductController {
    
    // 需要 product:add 权限
    @PostMapping("/add")
    @PreAuthorize("hasAuthority('product:add')")
    public ResultDTO<Integer> addProduct(@RequestBody AddProductDTO dto) {
        // ...
    }
    
    // 需要 product:view 权限
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('product:view')")
    public ResultDTO<ProductVO> getProduct(@PathVariable Integer id) {
        // ...
    }
    
    // 需要 product:delete 权限
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('product:delete')")
    public ResultDTO<Void> deleteProduct(@PathVariable Integer id) {
        // ...
    }
}
```

### 5.2 多权限组合

```java
// 需要同时拥有两个权限（AND）
@PreAuthorize("hasAuthority('product:view') and hasAuthority('product:edit')")
public ResultDTO<Void> someMethod() {
    // ...
}

// 拥有任一权限即可（OR）
@PreAuthorize("hasAuthority('product:add') or hasAuthority('product:edit')")
public ResultDTO<Void> someMethod() {
    // ...
}

// 需要特定角色
@PreAuthorize("hasRole('ADMIN')")
public ResultDTO<Void> someMethod() {
    // ...
}
```

### 5.3 Service 层权限检查

如果需要在 Service 层检查权限：

```java
@Service
public class ProductFacadeImpl implements ProductFacade {
    
    @Resource
    private PermissionQueryDomain permissionQueryDomain;
    
    public void someBusinessMethod(Integer userId) {
        // 检查用户是否有权限
        boolean hasPermission = permissionQueryDomain.hasPermission(
            userId, 
            "product:add"
        );
        
        if (!hasPermission) {
            throw new BusinessException(GlobalResultCode.PERMISSION_DENIED);
        }
        
        // 业务逻辑...
    }
}
```

## 6. 权限测试

### 6.1 测试流程

1. **登录获取 Token**
```http
POST http://localhost:8080/auth/login
Content-Type: application/json

{
  "username": "100001",
  "password": "Am20250914"
}
```

2. **使用 Token 访问接口**
```http
GET http://localhost:8080/product/1
Authorization: Bearer {your_token}
```

3. **测试无权限访问**
   - 使用没有权限的用户登录
   - 访问需要权限的接口
   - 应该返回 403 Forbidden

### 6.2 查看用户权限

```sql
-- 查看用户拥有的后端权限
SELECT 
    u.id AS user_id,
    u.username,
    r.name AS role_name,
    pb.name AS permission_name,
    pb.permission_code AS permission_code,
    pb.type AS permission_type
FROM user u
JOIN user_role ur ON u.id = ur.user_id
JOIN role r ON ur.role_id = r.id
JOIN role_permission_bk rpb ON r.id = rpb.role_id
JOIN permission_bk pb ON rpb.permission_id = pb.id
WHERE u.id = 1  -- 替换为实际用户ID
  AND ur.is_delete = 0
  AND rpb.is_delete = 0
  AND pb.is_delete = 0
ORDER BY pb.type, pb.`order`;
```

## 7. 权限管理最佳实践

### 7.1 权限粒度设计

**推荐：**
- 模块级：`product`
- 菜单级：`product:list`
- 操作级：`product:add`, `product:edit`, `product:delete`

**不推荐：**
- 过细：`product:list:page1`, `product:edit:field1`
- 过粗：`product:all`

### 7.2 权限命名规范

- 使用小写字母
- 使用冒号分隔
- 动词在后：`product:add` 而不是 `add:product`
- 保持一致性

### 7.3 权限分配原则

- **最小权限原则**：只分配必要的权限
- **角色分离**：不同角色有不同权限
- **权限继承**：利用角色层次实现权限继承

## 8. 权限集成检查清单

- [ ] 在 `permission_bk` 表中添加了后端权限
- [ ] 在 Controller 方法上添加了 `@PreAuthorize`
- [ ] 权限码与数据库中的一致
- [ ] 使用超级管理员测试了功能访问
- [ ] 通过前端为其他角色分配了权限
- [ ] 测试了有权限的访问
- [ ] 测试了无权限的访问
- [ ] 前端菜单配置（参考前端文档）

## 9. 下一步

权限配置完成后，可以：

1. 使用现有模块功能（参考《5.使用现有模块.md》）
2. 开发前端页面
3. 进行完整的功能测试

---

**提示：** 权限配置是系统安全的重要环节，建议仔细测试各种权限组合，确保权限控制正确有效。
